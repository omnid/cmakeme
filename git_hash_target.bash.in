#!/usr/bin/env bash
# Usage: git_hash_target.bash TARGET HEADER <file|directory>...
# Compute the hash for a TARGET and output it to HEADER.
# The HEADER file defines TARGET_HASH with the git hash from
# If a file is specified directly it will be included in the hash
# Files and directories that do not exist are excluded from the hash
# (this allows passing sending yyy-NOTFOUND from CMake without issue)
# If a directory is specified, then all files matching *.h, *.hpp, *.hxx and *.in will be included
target=$1
header=$2
shift
shift

files=()
for filedir in "$@"
do
    if [[ -d "$filedir" ]]
    then
        # Read all files recursively in the directory into an array, specifically selecting files with the desired extension.  and get the absolute path
       readarray -d '' array < <(cd $filedir && find . -type f -path '*.h' -or -path '*.hpp' -or -path '*.hxx' -or -path '*.in' -exec realpath {} \; )
       files=(${files[@]} ${array[@]})
    elif [[ -f "$filedir" ]]
    then
        files+=("$filedir")
    fi
done

# concatenate all the files and run them through git hash
hash=$(cat ${files[@]} | @GIT_EXECUTABLE@ hash-object --stdin)

# make the header
mkdir -p "${header%/*}"
cat > "$header" <<EOF
// Automatically generated by git_hash_target.bash
// DO NOT MODIFY.  
#ifndef ${target^^}_GIT_HASH_INCLUDE_GUARD
#define ${target^^}_GIT_HASH_INCLUDE_GUARD
#include "cmakeme/git_hash.h"
#define ${target^^}_HASH "$hash"
#endif
EOF


