#!/usr/bin/env bash
# Usage: git_hash_target.bash TARGET HEADER <file|directory>...
# Compute the hash for a TARGET and output it to HEADER.
# The HEADER file defines TARGET_HASH with the git hash from
# If a file is specified directly it will be included in the hash
# Files and directories that do not exist are excluded from the hash
# (this allows passing sending yyy-NOTFOUND from CMake without issue)
# If a directory is specified, then all files matching *.h, *.hpp, *.hxx and *.in will be included
allargs=$@ # get all arguments: used for debugging information

target=$1
header=$2
shift
shift

# Split on semicolon and space. The ; comes from CMAKE when passing
# the result of generator expressions
IFS='; ' read -ra args <<< "$@"

files=()
for filedir in "${args[@]}"
do
    if [[ -d "$filedir" ]]
    then
        # Read all files recursively in the directory into an array, specifically selecting files with the desired extension.  and get the absolute path
       readarray -d '' array < <(cd $filedir && find . -type f -path '*.h' -or -path '*.hpp' -or -path '*.hxx' -or -path '*.in' -exec realpath {} \; )
       files=(${files[@]} ${array[@]})
    elif [[ -f "$filedir" ]]
    then
        files+=("$filedir")
    fi
done

# concatenate all the files and run them through git hash
hash=$(cat ${files[@]} | @GIT_EXECUTABLE@ hash-object --stdin)

# make the header
mkdir -p "${header%/*}"
cat > "$header" <<EOF
// Automatically generated by git_hash_target.bash
// DO NOT MODIFY.  
// The command that generated this file was:
// $allargs
//
// $args
#ifndef ${target^^}_GIT_HASH_INCLUDE_GUARD
#define ${target^^}_GIT_HASH_INCLUDE_GUARD
#include "@PROJECT_NAME@/@PROJECT_NAME@_git_hash.h"

// GIT_HASH_${target^^} is derived from the following files:
// ${files[@]}
#define GIT_HASH_${target^^} "$hash"
#endif
EOF


